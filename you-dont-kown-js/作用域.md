### 第1章 作用域是什么

#### 1.1 编译原理

尽管通常将```JavaScript```归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中进行移植。

在传统编译语言的流程中，程序中一段源代码在执行之前会尽力三个步骤，即“编译”：

- 分词/词法分析（Tokenizing/Lexing）

这个过程会将由字符组成的字符串分解成有意义的代码块，这些代码块被成为**词法单元**。

```
var a = 2; 
//分解成 var、a、=、2、；。
//空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。
```

分词和词法分析主要**差异**在于词法单元的识别是通过有状态还是无状态的方式进行的。

简单的说，如果词法单元生成器在判断```a```是一个独立的词法单元还是其他词法单元的一部分时, 调用的是有状态的解析规则，那么这个过程就被称为**词法分析**。

- 解析/语法分析（Parsing）

这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“**抽象语法树**”（Abstract Syntax Tree, AST）。


![](https://user-gold-cdn.xitu.io/2019/2/20/1690b25f4ad19e1d?w=761&h=506&f=jpeg&s=33135)

- 代码生成

将AST转换为可执行代码的过程被称为代码生成。

抛开具体细节，简单来说就是有某种方法可以将```var a = 2;```的AST转化为一组机器指令，用来创建一个叫作```a```的变量（包括分配内存等），并将一个值储存```a```中。

JS引擎要复杂的多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

#### 1.2 理解作用域

**作用域**：负责收集并维护由所有的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

- 编译器
    - LHS查询（目的是对变量赋值）
    - RHS查询（获取变量的值）
    
    当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。

#### 1.3 作用域嵌套（由内到外查找）
#### 1.4 异常

如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出```ReferenceError```异常。

相较之下，当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。（严格模式禁止自动或隐式地创建全局变量）

```ReferenceError```同作用域判别失败相关，而```TypeError```则代表作用域判别成功了，但是对结果的操作时非法或不合理的。
